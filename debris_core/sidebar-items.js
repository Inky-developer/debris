initSidebarItems({"enum":[["BuildMode","The build mode for this compilation"],["OptMode","How to optimize the code"],["Type","The type of a class object"],["TypePattern","The enumeration of patterns allowed as function arguments"]],"mod":[["class","This module defines classes. The concept of a class should be similar to the equivalent concept in other languages. Every value (`object`) has a class. Builtin values have a class with an associated type, while user defined classes, like structs, carry a reference to the concrete struct."],["compile_context",""],["config",""],["debris_object",""],["error","Compilation error handling"],["function_interface","This module contains a trait `ToFunctionInterface` which allows to write nice function interfaces by using much less boilerplate to define functions."],["hir","High-level intermediate representation"],["llir","Low-level intermediate representation"],["memory",""],["mir","Mid-level intermediate representation"],["namespace",""],["objects","Contains all objects which can be used in a debris program."],["types",""]],"struct":[["CompileContext","The Compilation context stores various information about the current compilation"],["Config","Holds data about the user specified configuration"],["DebrisObject","Objects are a central type for the compiler. Basically anything that can be assigned to a variable is an object. This includes numbers, function, modules, and more. It is possible to cast the ObjectPayload to its original value. Because [DebrisObject] is unsized, it generally only accessed as [ObjectRef]"],["Namespace",""],["ObjectRef","This struct is used to pass objects arround"]],"trait":[["ObjectPayload","A trait for values that can be used as debris object payload"],["ValidPayload",""]],"type":[["ObjectProperties","The type of the properties map"]]});