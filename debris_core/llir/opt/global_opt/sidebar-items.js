initSidebarItems({"constant":[["DEBUG","If true prints some debug information to stdout"]],"enum":[["OptimizeCommandKind","Optimizing functions output commands that tell the optimizer what to do, this is done so that there are no troubles with mutability"]],"fn":[["alias_function_optimizer","This optimizer handles functions that alias other function. An aliasing function consists of only one node, which calls another function. If such a function is found, it gets deleted and all references to it get moved to the aliased function. This prevents the optimizer from inlining into an aliasing function, reducing the code size."],["optimize_call_chain","Inlines the function call chain. This optimizer only runs once, at the start."],["optimize_common_path","This expensive optimization searches for common paths at conditionals."],["simple_arithmetic_optimization","Optimizes basic arithmetic expressions with the shape x OP constant OP constant â€¦ NOTE: This optimizer changes the runtime behavior! An operation like `a * 2000 / 1000` can cause an overflow, while the optimized version `a * 2` might not. For this reason it is very important that this optimizer is not toggled between release and debug mode."]],"struct":[["CodeStats","tracks statistics about the global code which can be used to allow some optimizations"],["Commands","Interface for optimizing functions to get data about the code and emit optimization instructions"],["ConstOptimizer","Optimizes nodes which are const-evaluatable. This optimizer tracks all const assignments to variables in a given function and replaces reads from const variables by their const value. Also contains functionality to evaluate [BinaryOperation] and [Condition]. In order to be more efficient, this optimizer optimizes an entire function. This means that the current state must always be synced correctly!"],["GlobalOptimizer","Does optimization on the whole program."],["OptimizeCommand",""],["OptimizeCommandDeque","Just a wrapper arround deque with a simple push method"],["RedundancyOptimizer",""],["RedundantCopyOptimizer",""]],"trait":[["Optimizer",""]],"type":[["NodeId","The optimizer can uniquely identify each node with this type"]]});